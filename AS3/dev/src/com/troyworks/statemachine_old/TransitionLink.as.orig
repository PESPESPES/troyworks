import com.troyworks.statemachine.*;
class com.troyworks.statemachine.TransitionLink extends com.troyworks.datastructures.graph.MicroLink {
	public var className:String = "com.troyworks.statemachine.TransitionLink";
	public var core:StateCore;
	public function TransitionLink(id:Number,  name:String, Type:String){
		super(id, name, Type);
	}
	public function toString():String{
		return "transition link is " + this.name;
	}
	/////////////////////statemangement stuff ////////////////////////
	public function fire():Void {
		var fN:IState = IState(this._fromNode);
		//if from isn't active ignore it,
		if(fN.getIsActive() == StateNode.ACTIVE){
			trace("firing mlink: " + this.name + " internal? " + (this._toNode === this._fromNode.parent) );
			trace("topmost on stack ?" + fN.getIsFrontMost());
			//to from
			trace("\t " + this._toNode.name + " " + this._fromNode.name  );
			trace("\t " + this._toNode.parent.name + " " + this._fromNode.parent.name  );

			if(this._toNode.parent != this._fromNode ){
		//	   this.core.leavingNodes.push(this._fromNode);
		//	   this.core.internalActionNodes.push({target:this._fromNode.parent, event:"internalTransition", name:this.name});
			}else {
		//	   this.core.internalActionNodes.push({target:this._fromNode, event:"internalTransition", name:this.name});
	//
			}
			//if this isn't the frontmost node, then get the path from
			var res = null;
			if(fN.getIsFrontMost()){
				res =this.core.findHeirachicalPath(this._fromNode, this._toNode);
			}else{
				var frontMost:Array = this.core.getFrontMostNodes();
				if(frontMost.length> 0){
				//TODO add merge for paths when frontmost nodes is greater than 1
					res =this.core.findHeirachicalPath(frontMost[0], this._toNode);

				}else {
					trace("invalid state ");
					return;
				}
			}
			//if(res.direction <0){
				//if direction is down it's the right way for an exit.
				var _array = res.exitList;
				var i = _array.length;
				var evt = new Object();
				evt.sig = "LEAVE";
				trace("adding LEAVE events: " + i);
				for (var i = 0; i<_array.length; i++) {
					var evtRes = new SimpleEventResponse();
					trace(" adding exit event for " + _array[i].name);
					_array[i].handleEvent(evt, evtRes);
					//this.core.addEventToList(evt);
				}
				var _array = res.tranList;
				var i = _array.length;
				var evt = new Object();
				evt.sig= "CROSS";
				trace("adding CROSS events: " + i);
				for (var i = 0; i<_array.length; i++) {
					var evtRes = new SimpleEventResponse();
					_array[i].handleEvent(evt, evtRes);
						trace(" adding cross event for " + _array[i].name);
					//this.core.addEventToList(evt);
				}
				var _array = res.enterList;
				var i = _array.length;
				var evt = new Object();
				evt.sig = "ENTER";
				trace("adding ENTER events: " + i);
				if(i > 1){
					//keep root nodes from fireing on multi level transitions.
					evt.multi = true;
				}
				for (var i = 0; i<_array.length; i++) {
					if(i== _array.length -1){
						evt.multi = false;
					}
					var evtRes = new SimpleEventResponse();
					_array[i].handleEvent(evt, evtRes);
						trace(" adding enter event for " + _array[i].name);
					//this.core.addEventToList(evt);
				}
				this.core.dispatchEvents();
				//	this.core.firingLinks.push(this);
				//	this.core.enteringNodes.push(this._toNode);
				//	this.core.onPerformActions();
			//}
		}else {
			trace("can't fire, invalid transition: from state " + this._fromNode.name +  "  isn't active!");
		}

	}
	public function onCross():Void {
		trace("crossing " + this.name);
	}
	public function onFired():Void {
		trace("onFired " + this.name);
	}
}